[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial: Advanced data visualization in R",
    "section": "",
    "text": "This is the supporting material for the tutorial Advanced data visualization in R which takes place 28.02.2024 09:00-12:00. Here is the tutorial description as displayed on the website’s conference program:"
  },
  {
    "objectID": "index.html#data-prep",
    "href": "index.html#data-prep",
    "title": "Tutorial: Advanced data visualization in R",
    "section": "Data prep",
    "text": "Data prep\nThe data is courtesy of the Gapminder foundation and can easily be accessed via the {gapminder} package. We can then make use of the pipe operator %&gt;% to create a subset of the data via the filter() function. Then, in order for our ggplot to work as intended in the next step, we also need to format the year column as a factor instead of an integer value via mutate(). Both functions are from the {dplyr} package which we loaded as part of the {tidyverse}. Finally, we use droplevels() to get rid of the factor levels that are now no longer present in the data (i.e. the countries we did not filter for).\n\ndat &lt;- gapminder::gapminder %&gt;% \n  filter(year == 1952 | year == 2007) %&gt;% \n  filter(country %in% c(\"Canada\", \"Germany\", \"Japan\", \"Netherlands\", \"Nigeria\", \"Vietnam\", \"Zimbabwe\")) %&gt;% \n  mutate(year = as.factor(year)) %&gt;% \n  droplevels()\n\ndat\n#&gt; # A tibble: 14 × 6\n#&gt;    country     continent year  lifeExp       pop gdpPercap\n#&gt;    &lt;fct&gt;       &lt;fct&gt;     &lt;fct&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n#&gt;  1 Canada      Americas  1952     68.8  14785584    11367.\n#&gt;  2 Canada      Americas  2007     80.7  33390141    36319.\n#&gt;  3 Germany     Europe    1952     67.5  69145952     7144.\n#&gt;  4 Germany     Europe    2007     79.4  82400996    32170.\n#&gt;  5 Japan       Asia      1952     63.0  86459025     3217.\n#&gt;  6 Japan       Asia      2007     82.6 127467972    31656.\n#&gt;  7 Netherlands Europe    1952     72.1  10381988     8942.\n#&gt;  8 Netherlands Europe    2007     79.8  16570613    36798.\n#&gt;  9 Nigeria     Africa    1952     36.3  33119096     1077.\n#&gt; 10 Nigeria     Africa    2007     46.9 135031164     2014.\n#&gt; 11 Vietnam     Asia      1952     40.4  26246839      605.\n#&gt; 12 Vietnam     Asia      2007     74.2  85262356     2442.\n#&gt; 13 Zimbabwe    Africa    1952     48.5   3080907      407.\n#&gt; 14 Zimbabwe    Africa    2007     43.5  12311143      470."
  },
  {
    "objectID": "index.html#the-base-plot",
    "href": "index.html#the-base-plot",
    "title": "Tutorial: Advanced data visualization in R",
    "section": "The base plot",
    "text": "The base plot\nOne typical way you may find data like this visualized is via a grouped bar plot. The minimum amount of code to create such a plot via ggplot is this:\n\nggplot(data = dat) +\n  aes(x = lifeExp, y = country, fill = year) +\n  geom_col(position = position_dodge())\n\n\n\n\nRead this if you are not familiar with the general ggplot syntax. We need to add position = position_dodge() to geom_col(), since the default is to stack the multiple bars (for the different years) on top of each other (as seen in the Nature example plot below).\n\n(factor) level reordering\nIt may seem irritating that countries are sorted alphabetically starting at the bottom. Moreover, 1952 is below 2007 in the plot (but not in the legend!). This is because these two columns are formatted as factors in our data and by default factor levels are sorted alphabetically.\nNote that ggplot applies this factor level order, but does it so from bottom to top.\n\nlevels(dat$country)\n#&gt; [1] \"Canada\"      \"Germany\"     \"Japan\"       \"Netherlands\" \"Nigeria\"    \n#&gt; [6] \"Vietnam\"     \"Zimbabwe\"\n\nA useful package for dealing with factors in R is {forcats} whose functions all start with fct_*. One way of dealing with this is changing the factor level order in the data before passing it to ggplot. Here, we may simply reverse the order via fct_rev().\n\ndat &lt;- dat %&gt;% \n  mutate(across(c(country), ~ fct_rev(.x)))\n\n\nlevels(dat$country)\n#&gt; [1] \"Zimbabwe\"    \"Vietnam\"     \"Nigeria\"     \"Netherlands\" \"Japan\"      \n#&gt; [6] \"Germany\"     \"Canada\"\n\n\nggplot(data = dat) +\n  aes(x = lifeExp, y = country, fill = year) +\n  geom_col(position = position_dodge())\n\n\n\n\n\n\nAlternative 1\n# alternatively, you may apply fct_rev() inside aes() instead of altering the data beforehand \nggplot(data = dat) +\n  aes(x = lifeExp, y = fct_rev(country), fill = year) +\n  geom_col(position = position_dodge())\n\n\n\n\nAlternative 2\n# alternatively, you may manually provide the levels in the desired order within scale_y_discrete()\nggplot(data = dat) +\n  aes(x = lifeExp, y = country, fill = year) +\n  geom_col(position = position_dodge()) +\n  scale_y_discrete(limits = c(\"Zimbabwe\", \"Vietnam\", \"Nigeria\", \"Netherlands\", \"Japan\", \"Germany\", \"Canada\"))\n\n\nHowever, it probably makes more sense to sort the countries according to the data. Here, we could sort them according to their life expectancy in 2007.\n\nsorted_countries &lt;- dat %&gt;% \n  filter(year == \"2007\") %&gt;% \n  arrange(lifeExp) %&gt;% \n  pull(country) %&gt;% \n  as.character()\n\ndat &lt;- dat %&gt;% \n  mutate(country = fct_relevel(country, sorted_countries))\n\nggplot(data = dat) +\n  aes(x = lifeExp, y = country, fill = year) +\n  geom_col(position = position_dodge())\n\n\n\n\nNext, we address the order of years in the plot and the legend. As you can see in the previous plots, once more the first factor level (1952) is on the bottom, while the second level (2007) is on top. Thus, we could use one of the approaches shown for country to change that. More precisely, let’s take the approach of Alternative 1 and use fct_rev() inside the aes().\nNote however, that while this changes the order of the years in the plot, it does not affect their order in the legend. To address that, we can use the limits = argument in scale_fill_manual() (which corresponds to Alternative 2 above):\n\nggplot(data = dat) +\n  aes(x = lifeExp, y = country, fill = fct_rev(year)) +\n  geom_col(position = position_dodge()) +\n  scale_fill_discrete(limits = c(\"1952\", \"2007\"))\n\n\n\n\n\n\nAlternative\n# alternatively, you may reverse the legend order via guides()\nggplot(data = dat) +\n  aes(x = lifeExp, y = country, fill = fct_rev(year)) +\n  geom_col(position = position_dodge()) +\n  guides(fill = guide_legend(reverse = TRUE))"
  },
  {
    "objectID": "index.html#reproducing-a-theme",
    "href": "index.html#reproducing-a-theme",
    "title": "Tutorial: Advanced data visualization in R",
    "section": "Reproducing a theme",
    "text": "Reproducing a theme\nNow that we’ve got the basics correct, the next thing I would want to change is things like the theme, i.e. the non-data components of the plot: titles, labels, fonts, background, gridlines, and legends.\nUsing theme() allows us to format our plot in any way we want. Instead of picking things based on what feels good, let us here try to recreate the layout of a plot published in Nature in ‘150 years of Nature: a data graphic charts our evolution’ by Richard Monastersky & Richard Van Noorden (2019). URL to the plot.\n\nThus, a better starting point would be to use the complete theme theme_minimal() instead of the default theme_gray(). From here, we can further adjust things via theme().\nFurthermore, let’s also pick two of the colors used in that image (e.g. via any online color picker) for our years. We can create a named vector year_colors and when changing scale_fill_discrete() to scale_fill_manual() supply it via the values = argument.\nFinally, as our ggplot-code is getting longer, let’s start saving out current plot into an object p and reuse it.\n\nyear_colors &lt;- c(\"1952\" = \"#37A9E1\", \"2007\" = \"#F7AA59\")\n\np &lt;- ggplot(data = dat) +\n  aes(x = lifeExp, y = country, fill = fct_rev(year)) +\n  geom_col(position = position_dodge()) +\n  scale_fill_manual(\n    name = \"Year\",\n    limits = names(year_colors), \n    values = year_colors) +\n  theme_minimal(base_size = 12)\n\np\n\n\n\n\n\nfont\nTo further replicate the aesthetics of the Nature plot, we introduce a custom font named Kanit. This font, available through Google Fonts, has been chosen for its stylistic resemblance to the one used in the Nature publication.\nThe process begins by fetching the font from Google Fonts and making it available for use in our R session via sysfonts::font_add_google(\"Kanit\", \"kanit\"). Next, showtext::showtext_auto() activates the use of custom fonts in plots. It’s important to also run showtext::showtext_opts(dpi = 300) to avoid getting unexpected results. This is because {showtext} uses a default of 72 dpi, while e.g. exporting plots via ggsave() defaults to dpi = 300. Furthermore, you may also want the dpi to be 300 (or some other number) when rendering plots within your RMarkdown via knitr::opts_chunk$set(dpi = 300) or quarto document via fig-dpi: 300.\nWe add a title and subtitle via labs() and then apply the font to all text elements via text = element_text(family = \"kanit\"). For some reason, the default position of title and subtitle in a ggplot is left-aligned with the y-axis - to instead left-align it with the left side of the entire plot, we apply plot.title.position = \"plot\". Making the title a bit bigger and bold is straightforward. However, having a subtitle (or other text elements) that has automatic line breaks when the string is too long actually requires {ggtext} and more specifically a ggtext::element_textbox_simple() instead of the default ggplot2::element_text().\n\nsysfonts::font_add_google(\"Kanit\", \"kanit\")\nshowtext::showtext_auto()\n# We alreday did this above, but dont forget about it:\n# showtext::showtext_opts(dpi = 300)\n\nlong_subtitle &lt;- \"In the mid-twentieth century, global life expectancy was shaped by post-war recovery, with variations stark across countries. As decades progressed, public health advances and socioeconomic growth painted a new picture of longevity. The data now reflect a world where life expectancy in 2007 often mirrors a vastly improved quality of life compared to 1952.\"\n\np &lt;- p +\n  labs(\n    title = \"LIFE EXPECTANCY\",\n    subtitle = long_subtitle\n  ) +\n  theme(text = element_text(family = \"kanit\")) +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(size = 15, face = \"bold\"),\n    plot.subtitle = ggtext::element_textbox_simple(size = 10, margin = margin(5, 0, 5, 0))\n  )\n\np\n\n\n\n\n\n\naxes\nFor our specific goal, we start by removing the axis titles as well as unnecessary space beyond the limits of each axis. Furthermore, there should be no axis line for the y-axis and a relatively thick black line with grey ticks for the x-axis. More details on axis formatting can be found here.\n\np &lt;- p +\n  scale_y_discrete(\n    name = NULL, # remove title\n    expand = c(0,0) # no extra space above or below\n  ) + \n  scale_x_continuous(\n    name = NULL, # remove title\n    expand = expansion(mult = c(0, 0.05)) # only 5% extra space above upper limit\n  ) +\n  theme(\n    axis.line.y = element_blank(), # remove line on y-axis\n    axis.text.x = element_text(color = \"#AAAAAA\"), # x-axis label color\n    axis.ticks.x = element_line(color = \"#AAAAAA\", linewidth = 0.4), # x-axis tick color & width\n    axis.ticks.length.x = unit(4, \"pt\"), # x-axis tick length\n    axis.line.x = element_line(color = \"black\", linewidth = 0.6) # x-axis line color & width\n  )\n\np\n\n\n\n\n\n\nlegend\nOur legend is supposed to be above the plot and left-aligned. We partly achieve this via legend.position, legend.box.just and legend.justification, but unfortunately this does not fully achieve the goal. We want to have a legend that is left-aligned with respect to the entire plot, not to the y-axis. As far as I know and unlike plot.title.position = \"plot\" which we used above, there is no way of achieving this normally. Thus, we here use a hack by setting the left margin() of the legend to a negative value that looks good enough.\nBesides the position, the legend title is made bold via legend.title = element_text(face = \"bold\") and we force all elements of the legend to be in one row via guide_legend(title.position = \"left\", nrow = 1). Finally, the size of the colored squares in the legend is reduced via legend.key.size = unit(0.4, \"cm\").\n\np &lt;- p +\n  guides(\n    fill = guide_legend(\n      title.position = \"left\",\n      nrow = 1)\n  ) +\n  theme(\n    legend.position = \"top\",\n    legend.box.just = \"left\",\n    legend.justification = \"left\",\n    legend.margin = margin(5, 0, 0, -57, unit = \"pt\"),\n    legend.title = element_text(face = \"bold\"),\n    legend.key.size = unit(0.4, \"cm\")\n  )\n\np\n\n\n\n\n\n\ngrid lines\nLastly, we could adjust the grid lines. By default, ggplot has major and minor grid lines for both axes. Yet, we only want thin, dotted, grey lines for the major grid of the x-axis:\n\np &lt;- p +\n  theme(\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(linetype = \"dotted\", color = \"#AAAAAA\", linewidth = 0.3)\n  )\n\np"
  },
  {
    "objectID": "index.html#improve-the-plot",
    "href": "index.html#improve-the-plot",
    "title": "Tutorial: Advanced data visualization in R",
    "section": "Improve the plot",
    "text": "Improve the plot\nWe have now mostly reproduced the layout of the Nature plot and applied it to our plot. At this point, we could try out things that may improve the plot.\n\nLabels\nIn certain cases it can be beneficial to additionally label data points. In this plot, we may simply label each bar with rounded life expectancy it represents. We here do so via geom_text() where aes(label = round(lifeExp)). Note that we also need to add group = fct_rev(year) here. This is because so far we applied fill = fct_rev(year) in the general aes() which led to different groups due to the different fill colors so that geom_col(position = position_dodge()) knew which groups/bars were supposed to be dodged. However, our labels created via geom_text() do not have a fill attribute but should still be dodged per year in the same way. Hence, group = fct_rev(year) is required and moreover, position_dodge(width = 0.9) actually needs a width value here set to the default dodge with for bars.\nOnce this is out the way, we make the text white and right-align it with extra space via a value for hjust that is larger than 1. Finally, don’t forget to apply family = \"kanit\" here as well, as geoms are not part of the theme() and thus this geom_text() knows nothing about Kanit.\n\np &lt;- p +\n  geom_text(\n    mapping = aes(label = round(lifeExp), group = fct_rev(year)), \n    position = position_dodge(width = 0.9),\n    hjust = 1.1,\n    color = \"white\",\n    family = \"kanit\"\n  )\n\np\n\n\n\n\n\n\nDumbbell plot\nWhen it comes to visualizing changes or differences between two data points (like life expectancy across two different years in our case), dumbbell plots can offer a clearer and more direct comparison than grouped bar plots. While grouped bar plots efficiently display the individual values, dumbbell plots excel in highlighting the actual change or difference between these values. They connect the two data points with a line, making it visually immediate to see the extent of change. This is particularly beneficial in cases where the focus of the analysis is on the change itself rather than the absolute values. Moreover, dumbbell plots reduce clutter and can be easier to read when dealing with a large number of categories. By using different colors for the points and a subtle line to connect them, dumbbell plots provide a balanced emphasis on both the individual data points and their relative change, thereby offering a more nuanced view of the data. This makes them an excellent choice for our comparison of life expectancies over time.\nTo create such a dumbbell plot, we need a transformed, wide version of our data (more on long/wide format here):\n\ndat_wide &lt;- dat %&gt;% \n  select(country, year, lifeExp) %&gt;% \n  pivot_wider(names_from = year, values_from = lifeExp, names_prefix = 'year_')\n\ndat_wide\n#&gt; # A tibble: 7 × 3\n#&gt;   country     year_1952 year_2007\n#&gt;   &lt;fct&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Canada           68.8      80.7\n#&gt; 2 Germany          67.5      79.4\n#&gt; 3 Japan            63.0      82.6\n#&gt; 4 Netherlands      72.1      79.8\n#&gt; 5 Nigeria          36.3      46.9\n#&gt; 6 Vietnam          40.4      74.2\n#&gt; 7 Zimbabwe         48.5      43.5\n\nFurthermore, we need most of what we did so far again with our ggplot object p again, but we do need to make some changes, which is why it makes sense to recreate p2 from scratch. Here are the changes:\n\nin the general aes() we use color = fct_rev(year) instead of fill = fct_rev(year)\naccordingly, we also use scale_color_manual() instead of scale_fill_manual()\nwe actually do want extra space beyond the limits for both axes so we remove the expand = statements\nwe no longer need bars created via geom_col()\nwe no longer the labels created via geom_text()\n\nGiven this, we have a well-prepared ggplot in need of geoms:\n\np2 &lt;- ggplot(data = dat) +\n  aes(x = lifeExp, y = country, color = fct_rev(year)) +\n  scale_color_manual(\n    name = \"Year\",\n    limits = c(\"1952\", \"2007\"), \n    values = year_colors\n  ) +\n  labs(\n    title = \"LIFE EXPECTANCY\",\n    subtitle = long_subtitle\n  ) +\n  scale_y_discrete(\n    name = NULL,\n  ) + \n  scale_x_continuous(\n    name = NULL,\n  ) +\n  guides(\n    fill = guide_legend(title.position = \"left\", nrow = 1)\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    text = element_text(family = \"kanit\"),\n    plot.title.position = \"plot\",\n    plot.title = element_text(size = 15, face = \"bold\"),\n    plot.subtitle = ggtext::element_textbox_simple(size = 10, margin = margin(5, 0, 10, 0)),\n    axis.line.y = element_blank(),\n    axis.text.x = element_text(color = \"#AAAAAA\"),\n    axis.ticks.x = element_line(color = \"#AAAAAA\", linewidth = 0.4),\n    axis.ticks.length.x = unit(4, \"pt\"),\n    axis.line.x = element_line(color = \"black\", linewidth = 0.6),\n    legend.position = \"top\",\n    legend.box.just = \"left\",\n    legend.justification = \"left\",\n    legend.margin = margin(5, 0, 0, -57, unit = \"pt\"),\n    legend.title = element_text(face = \"bold\"),\n    legend.key.size = unit(0.4, \"cm\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(linetype = \"dotted\", color = \"#AAAAAA\", linewidth = 0.3)\n  )\n\np2\n\n\n\n\nWe only need two geoms to create a dumbbell plot here: geom_segment() draws a straight line between points (x, y) and (xend, yend), which works nicely with the dat_wide created above. Note that the color = \"#AAAAAA\" overrides the color = fct_rev(year) from the general aes() that would otherwise apply. The points are automatically created and colored via geom_point() based on dat and the general aes().\n\np2 &lt;- p2 +\n  geom_segment(\n    data = dat_wide,\n    aes(x = year_1952, xend = year_2007, y = country, yend = country),\n    color = \"#AAAAAA\",\n    linewidth = 1\n  ) +\n  geom_point(size = 3)\n\np2\n\n\n\n\n\ndat_wide &lt;- dat_wide %&gt;% \n  mutate(\n    max_x = pmax(year_2007, year_1952),\n    diff_num = year_2007 - year_1952,\n    diff_chr = sprintf(\"%+d\", round(diff_num))\n  )\n\np2 &lt;- p2 +\n  geom_text(\n    mapping = aes(label = round(lifeExp)),\n    size = 2.5,\n    vjust = -1,\n    family = \"kanit\"\n  ) +\n  geom_text(\n    data = dat_wide,\n    inherit.aes = FALSE,\n    mapping = aes(y = country, x = max_x, label = diff_chr),\n    size = 2.5,\n    hjust = 0,\n    color = \"#AAAAAA\",\n    position = position_nudge(x = 1),\n    family = \"kanit\"\n  )\n\np2\n\n\n\n\nTODO\n\ndiscuss advantage\nremove legend and have colored text in subtitle instead"
  },
  {
    "objectID": "index.html#choosing-colors",
    "href": "index.html#choosing-colors",
    "title": "Tutorial: Advanced data visualization in R",
    "section": "Choosing colors",
    "text": "Choosing colors\nTODO\n\ncopy colors from nature plot\nuse viridis colors instead"
  }
]